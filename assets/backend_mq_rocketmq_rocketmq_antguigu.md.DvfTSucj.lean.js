import{_ as E,D as r,o as p,c as d,k as s,I as n,w as a,a as i,b as t,a4 as k,R as l}from"./chunks/framework.3IDgao2s.js";const Ls=JSON.parse('{"title":"1. RocketMq概述","description":"","frontmatter":{},"headers":[],"relativePath":"backend/mq/rocketmq/rocketmq_antguigu.md","filePath":"backend/mq/rocketmq/rocketmq_antguigu.md"}'),o={name:"backend/mq/rocketmq/rocketmq_antguigu.md"},c=l("",158),g=s("p",null,"刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为",-1),u=s("ul",null,[s("li",null,[s("p",null,"同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。")]),s("li",null,[s("p",null,"异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。")])],-1),y=l("",1),m=l("",7),b=s("em",null,"Master",-1),F=s("em",null,"RAID",-1),C=s("em",null,"Master",-1),A=l("",61),D=l("",40),B=s("p",null,"默认选择算法，该算法保证了每个Queue可以均匀的获取到消息",-1),_=s("ol",{start:"2"},[s("li",null,"最小投递延迟算法")],-1),q=s("p",null,"该算法会统计每次消息投递的时间延迟，然后根据统计出来的结果将消息投递到时间延迟最小的queue，如果延迟相同的话则采用轮询算法投递消息",-1),v=l("",64),f=l("",17),T=l("",1),S=l("",17),M=l("",6),x=l("",45),P=s("code",null,".rocketmq_offset/${clientId}/group/Offset.json",-1),R=s("code",null,"${clientId}",-1),I=l("",37),Q=s("p",null,"第一步已经判断过是否是重复性操作了。",-1),N=s("h4",{id:"_3-支付场景举例",tabindex:"-1"},[i("3. 支付场景举例 "),s("a",{class:"header-anchor",href:"#_3-支付场景举例","aria-label":'Permalink to "3. 支付场景举例"'},"​")],-1),O=s("li",null,"在分布式事务中完成三项操作:",-1),w=l("",7),L=s("h2",{id:"_8-消息堆积和消息延迟",tabindex:"-1"},[i("8. 消息堆积和消息延迟 "),s("a",{class:"header-anchor",href:"#_8-消息堆积和消息延迟","aria-label":'Permalink to "8.  消息堆积和消息延迟"'},"​")],-1),j=s("h3",{id:"_1-概念",tabindex:"-1"},[i("1. 概念 "),s("a",{class:"header-anchor",href:"#_1-概念","aria-label":'Permalink to "1. 概念"'},"​")],-1),G=l("",10),U=s("h3",{id:"_3-消费耗时",tabindex:"-1"},[i("3. 消费耗时 "),s("a",{class:"header-anchor",href:"#_3-消费耗时","aria-label":'Permalink to "3. 消费耗时"'},"​")],-1),V=s("p",null,"外部IO操作性代码",-1),K=s("ul",null,[s("li",null,"读写外部数据库"),s("li",null,"读写外部缓存"),s("li",null,"下游系统调用， 如Dubbo的RPC远程调用， HTTPClient调用等等")],-1),X=s("strong",null,"通常消失堆积是由于服务异常或者是达到了数据库的限制",-1),z=s("p",null,"服务异常： 不仅仅是500这种，还有网络带宽问题等",-1),J=s("h3",{id:"_4-消费并发度",tabindex:"-1"},[i("4. 消费并发度 "),s("a",{class:"header-anchor",href:"#_4-消费并发度","aria-label":'Permalink to "4. 消费并发度"'},"​")],-1),H=s("p",null,[i("一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为 *"),s("em",null,"单节点线程数*节点数量"),i("。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。")],-1),W=s("blockquote",null,[s("p",null,"单节点线程数：即单个Consumer所包含的线程数"),s("p",null,"节点数量：即Consumer Group中的Consumer数量")],-1),Y=s("blockquote",null,[s("ol",null,[s("li",null,"全局顺序消息: 该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为1。"),s("li",null,"分区顺序消息: 该类型消息的Topic有多Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费即，在同一时刻最多会出现多个Queue分有多Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。")])],-1),Z=s("h3",{id:"_5-单机线程数计算",tabindex:"-1"},[i("5. 单机线程数计算 "),s("a",{class:"header-anchor",href:"#_5-单机线程数计算","aria-label":'Permalink to "5. 单机线程数计算"'},"​")],-1),$=s("p",null,"对于一台主机中的线程池中的线程数的设置需要谨慎，不能盲目的直接调大线程数量，摄者过大的线程数反而会带来大量的线程切换的开销，理想环境下单节点的最有线程数计算模型为 C * (T1 + T2) / T1",-1),ss=s("ul",null,[s("li",null,"C: CPU内核数量"),s("li",null,"T1： CPU内部逻辑计算耗时"),s("li",null,"T2：外部IO计算耗时")],-1),is=s("h3",{id:"_6-如何避免",tabindex:"-1"},[i("6. 如何避免 "),s("a",{class:"header-anchor",href:"#_6-如何避免","aria-label":'Permalink to "6. 如何避免"'},"​")],-1),as=l("",10),ns=l("",6),es=s("h4",{id:"_1-2-异步发送消息",tabindex:"-1"},[i("1.2 异步发送消息 "),s("a",{class:"header-anchor",href:"#_1-2-异步发送消息","aria-label":'Permalink to "1.2 异步发送消息"'},"​")],-1),ls=s("p",null,"异步发送消息是指，Producer发出消息后无需等待MO返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。",-1),ps=s("h4",{id:"_1-3单向发送消息",tabindex:"-1"},[i("1.3单向发送消息 "),s("a",{class:"header-anchor",href:"#_1-3单向发送消息","aria-label":'Permalink to "1.3单向发送消息"'},"​")],-1),hs=l("",37),ts=s("strong",null,"和",-1),ks=l("",12),rs=l("",26),Es=s("p",null,"SCHEDULE_TOPIC_XXXX目灵中各个延时等级Queue中的消息是如何排序的?",-1),ds=l("",13),os=l("",16),cs=s("p",null,"引发消息回查的原因常见的有两个",-1),gs=s("ol",null,[s("li",null,"回调操作返回UNKOWN"),s("li",null,"TC没有收到TM的最终全局事务确认指令")],-1),us=l("",40),ys=l("",23),ms=s("code",null,"用户属性",-1),bs=l("",18),Fs=s("li",null,"生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的",-1),Cs=s("li",null,"只有普通消息具有发送重试机制，顺序消息是没有的",-1),As=s("li",null,"消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMO中是无法避免的问题",-1),Ds=s("li",null,"消息重复无法避免，但要避免消息的重复消费。",-1),Bs=s("li",null,"避免消息重复消费的解决方案是，为消息添加唯一标识，使消费者对消息进行消费判断来避免重复消费",-1),_s=s("li",null,"消息发送重试有三种策略可以选择:同步发送失败策略、异步发送失败策略、消息刷盘失败策略",-1),qs=s("h3",{id:"_2-同步发送失败策略",tabindex:"-1"},[i("2. 同步发送失败策略 "),s("a",{class:"header-anchor",href:"#_2-同步发送失败策略","aria-label":'Permalink to "2. 同步发送失败策略"'},"​")],-1),vs=s("p",null,"对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。",-1),fs=l("",14),Ts=l("",11),Ss=s("blockquote",null,[s("ol",null,[s("li",null,"这个重试队列是针对消息组的，而不是针对每个Topic设置的，一个Topic的消息可以让多个消费者组进行消费， 所以为这些消费者组个创建一个重试队列"),s("li",null,"只有当出现需要进行重试消费的消息是，才会为该消费者组创建重试队列")])],-1),Ms=l("",15);function xs(Ps,Rs,Is,Qs,Ns,Os){const e=r("font"),h=r("Mermaid");return p(),d("div",null,[c,s("blockquote",null,[g,u,s("p",null,[s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("刷盘带来的问题")]),_:1})])]),y]),m,s("p",null,[s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("以上优点的前提是，这些"),b,i("都配置了"),F,i("磁盘阵列。如果没有配置，一旦出现某"),C,i("宕机，则会发生大量消息丢失的情况。")]),_:1})])]),A,s("p",null,[s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("注意这种方式在正式的生产环境并不可以使用，否则挂一个就全挂了")]),_:1})])]),D,s("blockquote",null,[B,s("p",null,[s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("存在问题，如果某些broker上的queue投递延迟比较严重，会导致producer缓存队列中出现较大的消息挤压，影响消息的投递性能")]),_:1})])])]),_,s("blockquote",null,[q,s("p",null,[s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("存在的问题是消息分布不均匀")]),_:1})])])]),v,s("blockquote",null,[s("p",null,[i("该模式下Broker收到数据后会主动推送给Consumer。该获取方式一般实时性较高。该获取方式是典型的**"),n(e,{color:"blue"},{default:a(()=>[i("发布-订阅")]),_:1}),i("**模式，即Consumer向其关联的Queue注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是Consumer去Queue中拉取消息。而这些都是基于Consumer与Broker间的长连接的。长连接的维护是需要消耗系统资源的。")])]),f,n(e,{color:"red"},{default:a(()=>[i("消费暂停")]),_:1}),i("：在只有一个Consumer时，其负责消费所有队列；在新增了一个Consumer后会触发Rebalance的发生。此时原Consumer就需要暂停部分队列的消费，等到这些队列分配给新的Consumer后，这些暂停消费的队列才能继续被消费。"),n(e,{color:"red"},{default:a(()=>[i("消费重复")]),_:1}),i("：Consumer 在消费新分配给自己的队列时，必须接着之前Consumer 提交的消费进度的offset继续消费。然而默认情况下，offset是异步提交的，这个异步性导致提交到Broker的offset与Consumer实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。"),T,n(e,{color:"red"},{default:a(()=>[i("消费突刺")]),_:1}),i("：由于Rebalance可能导致重复消费，如果需要重复消费的消息过多，或者因为Rebalance暂停时间过长从而导致积压了部分消息。那么有可能会导致在Rebalance结束之后瞬间需要消费很多消息。"),S,s("p",null,[i("该算法是要根据"),n(e,{color:"blue"},{default:a(()=>[i("avg = QueueCount / ConsumerCount")]),_:1}),i(" 的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。")]),M,s("p",null,[i("该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。"),s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("该算法存在的问题：分配不均。")]),_:1})])]),x,s("p",null,[i("Consumer在广播消费模式下offset相关数据以json格式持久化到Consumer本地磁盘文件中，"),n(e,{color:"red"},{default:a(()=>[i("默认文件路径在当前与用户主目录下的 "),P]),_:1}),i("其中"),R,i("喂当前消费者ID，默认喂ip@DWFAULT; group为消费者组名称")]),I,s("blockquote",null,[Q,s("p",null,[i("能够进入第二步说明已经不是重复操作了。"),s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("这一步是否有效？")]),_:1})])]),s("p",null,[s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("一般缓存中的数据都是具有有效期的，缓存中的数据一单过期，就会发生缓存穿透，使请求直接到达DBMS")]),_:1})])])]),N,s("ol",null,[s("li",null,[i("当支付请求到达后，首先在Redis缓存中却获取key为"),n(e,{color:"blue"},{default:a(()=>[i("支付流水号")]),_:1}),i("的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识; 若value为空，则进入下一步操作")]),s("li",null,[i("到DBMS中根据"),n(e,{color:"blue"},{default:a(()=>[i("支付流水号")]),_:1}),i("查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识;若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理")]),O]),w,s("blockquote",null,[s("p",null,[s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("RocketMq能够保证消息不丢失，但是不能保证消息不重复")]),_:1})])])]),L,j,s("p",null,[i("消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多，这部分消息就被称为"),n(e,{color:"blue"},{default:a(()=>[i("堆积消息")]),_:1}),i("。消息出现堆积进而会造成消息的消费延迟。以下场景需要重点关注消息堆积和消费延迟问题:")]),G,s("p",null,[i("消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由"),n(e,{color:"blue"},{default:a(()=>[i("消费耗时和消费并发度")]),_:1}),i("决定。"),n(e,{color:"red"},{default:a(()=>[i("优先解决消费耗时在考虑并发问题")]),_:1})]),U,s("p",null,[i("影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型"),n(e,{color:"blue"},{default:a(()=>[i("CPU内部计算型代码和外部I/0操作型代码")]),_:1}),i("。 通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I/0操作来说几乎可以忽略.所以外部IO型代码是影响消息处理时长的主要症结所在")]),s("blockquote",null,[V,K,n(e,{color:"blue"},{default:a(()=>[i("提前梳理每个调用操作的预期好事，判断消费逻辑之中的IO操作号是是否合理")]),_:1}),i("，"),X,z]),J,H,W,s("p",null,[i("对于普通消息，延时消息和事务消息 并发计算都是 "),s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("单节点线程数*节点数量")]),_:1})]),i("，但是对于顺序消息则是不同的，顺序消息的消费并发度取决于 "),s("strong",null,[n(e,{color:"blue"},{default:a(()=>[i("Topic的Queue分区数量")]),_:1})])]),Y,Z,$,ss,n(e,{color:"red"},{default:a(()=>[i("注意：该计算出来的数值是理想装填下的理想数值，在生产环境中不建议直接使用，而是根据当前环境，先设置一个比改制小的数值然后看压测效果，然后在逐步调大直到到达最佳性能")]),_:1}),is,s("p",null,[i("为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是"),n(e,{color:"blue"},{default:a(()=>[i("梳理消息的消费耗时")]),_:1}),i("和"),n(e,{color:"blue"},{default:a(()=>[i("设置消息消费的并发度。")]),_:1})]),as,s("ul",null,[s("li",null,[i("文件过期，且到达"),n(e,{color:"blue"},{default:a(()=>[i("清理时间点 (默认为凌晨4点)后")]),_:1}),i("，自动清理过期文件")]),s("li",null,[i("文件过期，且磁盘空间占用率已达过期"),n(e,{color:"blue"},{default:a(()=>[i("清理警戒线默认75%")]),_:1}),i(")后，无论是否达到清理时间点，都会自动清理过期文件")]),s("li",null,[i("磁盘占用率达到"),n(e,{color:"blue"},{default:a(()=>[i("清理警戒线(默认85%)")]),_:1}),i("后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理")]),s("li",null,[i("磁盘占用率达到"),n(e,{color:"blue"},{default:a(()=>[i("系统危险警戒线 ")]),_:1}),i("(默认90%) 后，Broker将拒绝消息写入")])]),ns,s("p",null,[i("同步发送消息是指，Producer发送一条消息后，会收到Mq返回的ACK之后才下发下一条消息，该方式的"),n(e,{color:"red"},{default:a(()=>[i("消息可靠性最高，但是消息发送的效率太低")]),_:1}),i("。")]),(p(),t(k,null,{default:a(()=>[n(h,{id:"mermaid-2632",class:"mermaid my-class",graph:"sequenceDiagram%0Aparticipant%20p%20as%20%E5%8F%91%E9%80%81%E8%80%85%0Aparticipant%20mq%20as%20RocketMq%0Ap%20--%3E%3E%20mq%3A%201.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF1%0Amq%20--%3E%3E%20p%20%3A%202%E5%90%8C%E6%AD%A5%E5%93%8D%E5%BA%941%0Ap%20--%3E%3E%20mq%3A%203.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF2%0Amq%20--%3E%3E%20p%20%3A%204.%E5%90%8C%E6%AD%A5%E5%93%8D%E5%BA%942%0Ap%20--%3E%3E%20mq%3A%205.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF3%0Amq%20--%3E%3E%20p%20%3A%206.%E5%90%8C%E6%AD%A5%E5%93%8D%E5%BA%943%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),es,ls,(p(),t(k,null,{default:a(()=>[n(h,{id:"mermaid-2639",class:"mermaid my-class",graph:"sequenceDiagram%0Aparticipant%20p%20as%20%E5%8F%91%E9%80%81%E8%80%85%0Aparticipant%20mq%20as%20RocketMq%0Ap%20--%3E%3E%20mq%3A%201.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF1%0Amq%20--%3E%3E%20p%20%3A%20%E5%BC%82%E6%AD%A5%E5%93%8D%E5%BA%94%0Ap%20--%3E%3E%20mq%3A%202.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF2%0Amq%20--%3E%3E%20p%20%3A%20%E5%BC%82%E6%AD%A5%E5%93%8D%E5%BA%94%0Ap%20--%3E%3E%20mq%3A%203.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF3%0Amq%20--%3E%3E%20p%20%3A%20%E5%BC%82%E6%AD%A5%E5%93%8D%E5%BA%94%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),ps,s("p",null,[i("单向发送消息是指，Producer仅仅负责发送消息，不等待不处理Mq的ACK，该发送方式是Mq也不返回ACK，"),n(e,{color:"red"},{default:a(()=>[i("效率最高，可靠性较差")]),_:1})]),(p(),t(k,null,{default:a(()=>[n(h,{id:"mermaid-2646",class:"mermaid my-class",graph:"sequenceDiagram%0Aparticipant%20p%20as%20%E5%8F%91%E9%80%81%E8%80%85%0Aparticipant%20mq%20as%20RocketMq%0Ap%20--%3E%3E%20mq%3A%201.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF1%0Ap%20--%3E%3E%20mq%3A%202.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF2%0Ap%20--%3E%3E%20mq%3A%203.%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF3%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),hs,s("p",null,[i("根据有序范围的不同，RocketMO可以严格地保证两种消息的有序性: "),s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("分区有序")]),_:1}),ts,n(e,{color:"red"},{default:a(()=>[i("全局有序")]),_:1})])]),ks,n(e,{color:"red"},{default:a(()=>[i("取模算法存在一个问题: 不同选key与Queue数量取模结果可能会是相同的")]),_:1}),i("，即不同选择key的消息可能会出现在相同的queue，一个consumer可能会消费到不同选择key的消息。"),rs,s("blockquote",null,[Es,s("p",null,[i("是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC _XXXX目录下相Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时闻就取决于于"),n(e,{color:"blue"},{default:a(()=>[i("消息存储时间")]),_:1}),i("了，即按照消息被发送到Broker的时间进行排序的")])]),ds,s("p",null,[i("让1、2、3存在原子性，如果有一步失败则全部都回滚，使用"),n(e,{color:"blue"},{default:a(()=>[i("事务消息")]),_:1}),i("，使用"),n(e,{color:"blue"},{default:a(()=>[i("分布式事务")]),_:1}),i("解决。相应的概念可以参考Spring Cloud Seata。")]),os,s("blockquote",null,[n(e,{color:"red"},{default:a(()=>[i("注意：")]),_:1}),i("消息回查不是重新执行回调操作，回调操作时进行预扣操作，而消息回查则是查看预扣款操作执行的结果"),cs,gs]),us,(p(),t(k,null,{default:a(()=>[n(h,{id:"mermaid-3464",class:"mermaid my-class",graph:"flowchart%20LR%0AA%5BTopic%5D%20--%3E%20B%5BBody%5D%0AB%20--%3E%20C%5BLog%2020%E5%AD%97%E8%8A%82%5D%0AC%20--%3E%20D%5BProperties%5D%0A%0A%0A%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),ys,s("p",null,[i("sql过滤是一种通过特定表达式对事先埋入消息中的"),ms,i("进行筛选过滤的方式，通过SQL过滤可以实现对消息的复杂过滤，不过只有使用"),n(e,{color:"red"},{default:a(()=>[i("PUSH模式")]),_:1}),i("的消费者才能使用SQL过滤")]),bs,s("ul",null,[Fs,Cs,As,s("li",null,[i("消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件。producer主动重发、consumer负载变化（"),n(e,{color:"blue"},{default:a(()=>[i("发生rebalance，不会导致消息重复，但可能会出现重复消费")]),_:1}),i("）也会导致重复消息")]),Ds,Bs,_s]),qs,vs,n(e,{color:"blue"},{default:a(()=>[i("如果只有一个Broker，会尽量发送到该Broker的其他Queue上，因此顺序消息无法重试")]),_:1}),fs,s("p",null,[s("strong",null,[n(e,{color:"red"},{default:a(()=>[i("注意：顺序消息没有发送重试机制，但是有消费失败重试机制")]),_:1})])]),Ts,s("p",null,[i("对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。 当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为"),n(e,{color:"red"},{default:a(()=>[i("%RETRY%consumerGroup@consumerGroup")]),_:1}),i("的重试队列。")]),Ss,s("p",null,[i("消费重试的时间间隔与"),n(e,{color:"blue"},{default:a(()=>[i("延时消费的延时等级")]),_:1}),i("十分相似，除了没有延时等级的前两个时间，其他都是相同的")]),Ms])}const js=E(o,[["render",xs]]);export{Ls as __pageData,js as default};
