import{_ as E,D as r,o as h,c as d,b as k,w as a,a4 as t,k as s,I as n,a as i,R as l}from"./chunks/framework.3IDgao2s.js";const J=JSON.parse('{"title":"0. 简介","description":"","frontmatter":{},"headers":[],"relativePath":"backend/io/nio.md","filePath":"backend/io/nio.md"}'),g={name:"backend/io/nio.md"},y=l("",85),c=l("",3),b=l("",3),F=l("",11),o=s("h3",{id:"_3-limit",tabindex:"-1"},[i("3. limit "),s("a",{class:"header-anchor",href:"#_3-limit","aria-label":'Permalink to "3. limit"'},"​")],-1),u=l("",37),m=s("p",null,"Selector 一般称 为选择器，也可以翻译为 多路复用器 。它是 Java NIO 核心组件中的一个，用于检查一个或多个 NIO Channel(通道)的状态是否处于可读、可写。如此可以实现单线程管理多个 channels,也就是可以管理多个网络链接。",-1),C=s("p",null,"使用 Selector 的好处在于: 使用更少的线程来就可以来处理通道了，相比使用多个线程，避免了线程上下文切换带来的开销。",-1),A=s("h3",{id:"_2-可选通道-selectablechannel",tabindex:"-1"},[i("2. 可选通道（SelectableChannel） "),s("a",{class:"header-anchor",href:"#_2-可选通道-selectablechannel","aria-label":'Permalink to "2. 可选通道（SelectableChannel）"'},"​")],-1),D=s("ol",null,[s("li",null,[s("p",null,"不是所有的 Channel都可以被 Selector 复用的。比方说，FileChannel就不能被选择器复用。判断一个 Channel能被 Selecter 复用，有一个前提:判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复用，否则不能.")]),s("li",null,[s("p",null,"SelectableChannel类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有 socket通道，都继承了SelectableChannel类都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel类，没有继承 SelectableChannel，因此是不是可选通道。")]),s("li",null,[s("p",null,"一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通道和选择器之间的关系，使用注册的方式完成。SelectableChannel可以被注册到Selector 对象上，在注册的时候，需要指定通道的哪些操作，是Selector 感兴趣的。")])],-1),B=l("",8),f=s("code",null,"IllegalBlockingModeException",-1),v=s("li",null,"一个通道，并没有一定要支持所有的四种操作。比如服务器通道ServersocketChannel支持 Accept 接受操作，而 SocketChannel,客户端通道则不支持。可以通过通道上的 validOps()方法，来获取特定通道下所有支持的操作集合。",-1),S=l("",21),q=l("",5),_=l("",43),w=s("p",null,[i("不想使用 "),s("code",null,"queue"),i("可以直接在"),s("code",null,"selector.wakeUp()"),i("后注册。")],-1),x=l("",2),I=s("p",null,"对CPU密集操作的话建议使用，否则就预设好一个固定的数量就行了。",-1),P=s("p",null,"创建多个worker，让channel注册到不同的worker中。",-1),T=s("p",null,[i("在 "),s("code",null,"JDK10"),i("以后，可以通过 "),s("code",null,"jvm"),i("参数"),s("code",null,"UseContainerSupport"),i("配置，默认开启。")],-1),O=l("",1);function j(R,K,N,V,L,U){const e=r("Mermaid"),p=r("font");return h(),d("div",null,[y,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-724",class:"mermaid my-class",graph:"graph%20LR%0AC%5BChannel%5D%20--%3E%20B1%5BBuffer%5D%0AC%20--%3E%20B2%5BBuffer%5D%0AC%20--%3E%20B3%5BBuffer%5D%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),c,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-737",class:"mermaid my-class",graph:"graph%20LR%0AB1%5BBuffer%5D%20--%3E%20C%5BChannel%5D%0AB2%5BBuffer%5D%20--%3E%20C%0AB3%5BBuffer%5D%20--%3E%20C%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),b,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-753",class:"mermaid my-class",graph:"graph%20TD%0AB%5BBuffer%5D%20--%3EByte%5BByteBuffer%5D%0AB%20--%3E%20FloatBuffer%0AB%20--%3E%20LongBuffer%0AB%20--%3E%20DoubleBuffer%0AB%20--%3E%20IntBuffer%0AB%20--%3E%20CharBuffer%0AByte%20--%3E%20HeapByteBuffer%0AByte%20--%3E%20MappedByteBuffer%0A%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),F,s("ol",null,[s("li",null,[n(p,{color:"red"},{default:a(()=>[i("写数据到 Buffer时")]),_:1}),i("，position 表示写入数据的当前位置，position 的初始值为0。当一个 byte、long 等数据写到 Buffer后， position 会向下移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity-1(因为 position 的初始值为0）")]),s("li",null,[n(p,{color:"red"},{default:a(()=>[i("读数据到 Buffer时")]),_:1}),i("，position 表示读入数据的当前位置，如 position=2 时表示已开始读入了3个byte，或从第3个byte 开始读取。通过 ByteBuffer.flip()切换到读模式时 position 会被重置为 0，当 Buffer 从 position 读入数据后，position 会下移到下一个可读入的数据 Buffer 单元。")])]),o,s("ol",null,[s("li",null,[n(p,{color:"red"},{default:a(()=>[i("写数据时")]),_:1}),i("，limit 表示可对 Buffer 最多写入多少个数据。写模式下，limit 等于Buffer的 capacity。")]),s("li",null,[n(p,{color:"red"},{default:a(()=>[i("读数据时")]),_:1}),i("，limit 表示 Buffer 里有多少可读数据(not nul 的数据)，因此能读到之前写入的所有数据(limit 被设置成已写数据的数量，这个值在写式下就是position")])]),u,s("blockquote",null,[m,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-1018",class:"mermaid my-class",graph:"graph%20TD%0AS%5BSelector%5D%20--%E8%BD%AE%E8%AF%A2--%3E%20C1%5BChannel%5D%0AS%20--%E8%BD%AE%E8%AF%A2--%3E%20C2%5BChannel%5D%0AS%20--%E8%BD%AE%E8%AF%A2--%3E%20C3%5BChannel%5D%0AS%20--%E8%BD%AE%E8%AF%A2--%3E%20C4%5BChannel%5D%0AS%20--%E8%BD%AE%E8%AF%A2--%3E%20C5%5BChannel%5D%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),C]),A,D,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-1043",class:"mermaid my-class",graph:"graph%20TD%0AT%5BThread%5D%20--%3E%20S%5BSelector%5D%0AS%20--%3E%20SSC%5BServerSocket%20Channel%5D%0AS%20--%3E%20SC%5BSocket%20Channel%5D%0AS%20--%3E%20SC1%5BSocket%20Channel%5D%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),B,s("blockquote",null,[s("ol",null,[s("li",null,[i("与 Selector 一起使用时，"),n(p,{color:"red"},{default:a(()=>[i("Channel必须处于非阻塞模式")]),_:1}),i("下，否则将抛出异常"),f,i("。这意味着，FileChannel不能与 Selector 一起使用，因为 FileChanne!不能切换到非阻塞模式，而套接字相关的所有的通道都可以")]),v])]),S,(h(),k(t,null,{default:a(()=>[n(e,{id:"mermaid-1265",class:"mermaid my-class",graph:"graph%20LR%0Ata%5BThreadA%5D%0Asubgraph%20Pipe%0AsinC%5BSinkChannel%5D%20--%3E%20srcC%5BSourceChannel%5D%0Aend%0Ata--%3E%20sinC%0AsrcC%20--%3E%20ThreadB%0A"})]),fallback:a(()=>[i(" Loading... ")]),_:1})),q,s("ul",null,[s("li",null,[n(p,{color:"red"},{default:a(()=>[i("排它锁")]),_:1}),i(":又叫独占锁。对文件加排它锁后，该进程可以对此文件进行读写，该进程独占此文件，其他进程不能读写此文件，直到该进程释放文件锁。")]),s("li",null,[n(p,{color:"red"},{default:a(()=>[i("共享锁")]),_:1}),i(":某个进程对文件加共享锁，其他进程也可以访问此文件，但这些进程都只能读此文件，不能写。线程是安全的。只要还有一个进程持有共享锁，此文件就只能读，不能写。")])]),_,s("blockquote",null,[w,n(p,{color:"red"},{default:a(()=>[i("在两个不同的线程通信，可以使用ConcurrentLinkedQueue来传递参数")]),_:1})]),x,s("blockquote",null,[I,P,n(p,{color:"red"},{default:a(()=>[i("使用 `Runtime.getRuntime().availableProcessors()`获取CPU的线程数量，但是如果是在docker环境下，拿到的就是容器申请的cpu数量了。")]),_:1}),T]),O])}const M=E(g,[["render",j]]);export{J as __pageData,M as default};
