import{_ as E,D as r,o as h,c as d,k as s,I as l,w as n,b as k,a4 as t,a as i,R as a}from"./chunks/framework.3IDgao2s.js";const ks=JSON.parse('{"title":"1. 概述","description":"","frontmatter":{},"headers":[],"relativePath":"backend/io/netty.md","filePath":"backend/io/netty.md"}'),g={name:"backend/io/netty.md"},y=a("",3),c=a("",3),b=a("",44),F=s("p",null,[i("入栈的时候从前往后执行，"),s("code",null,"h1 --> h2 --> h3")],-1),o=s("p",null,[i("但是调用"),s("code",null,"channel.writeAndFlush()"),i("方法会跳转到"),s("code",null,"tail"),i("，然后从后往前找出栈的 "),s("code",null,"h5 --> h4")],-1),u=s("code",null,"channel.writeAndFlush",-1),m=s("code",null,"ctx.writeAndFlush",-1),A=a("",23),C=a("",15),D=s("p",null,"如果使用了relaese释放内存之后，再访问切片会出现错误，所以需要先retain再release",-1),B=a("",21),v=a("",9),f=s("p",null,[i("客户端和服务端约定好消息的长度，服务端使用固定长度的解码器"),s("code",null,"FixedLengthFrameDecoder"),i("来接收。")],-1),S=s("p",null,"如果设置的定长字节太难，会造成网络资源的浪费",-1),_=a("",20),w=s("p",null,[i("如果使用"),s("code",null,"ChannelInboundHandlerAdapter"),i(",解析出来的msg将会有两种类型，一种是"),s("code",null,"HttpContent"),i("一种是"),s("code",null,"HttpRequest"),i(".")],-1),q=s("p",null,[i("可以使用"),s("code",null,"SimpleChannelInboundHandler"),i("后边添加泛型来处理特定类型的消息。")],-1),T=s("code",null,"Codec",-1),x=a("",10),L=s("p",null,[i("注意这个"),s("code",null,"MessageCodec.encode()"),i("方法是"),s("code",null,"protected"),i("的，当前类需要和"),s("code",null,"MessageCodec"),i("在同一个包下。")],-1),O=s("p",null,[i("然后为了解决半包和粘包的问题，使用了"),s("code",null,"LengthFieldBasedFrameDecoder"),i("定长处理器来处理。")],-1),R=a("",1),j=s("p",null,[i("上述代码中的"),s("code",null,"MessageCodec"),i("接收的数据都是由定长处理器处理好的，也就不存在粘包和半包的问题，可不可以单独提出来标注"),s("code",null,"@Sharable"),i("呢？")],-1),N=a("",21),I=s("li",null,[i("属于 "),s("code",null,"SocketChannal"),i(" 参数")],-1),P=s("li",null,"SO_TIMEOUT 主要用在阻塞 10，阻塞 10 中 accept，read 等都是无限等待的，如果不希望永远阻塞使用用它调整超时时间",-1),H=a("",4),M=a("",15),G=a("",5),U=a("",5),z=s("p",null,[i("属于"),s("code",null,"SocketChannel"),i("参数，负责入站数据的分配，决定入站缓冲区的大小(并可动态调整)，统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定。")],-1),V=a("",2),K=a("",47),J=s("code",null,"io.netty.bootstrap.AbstractBootstrap#initAndRegister",-1),W=a("",1),Y=a("",3),Q=s("p",null,"NioEventLoop的重要组成：Selector,线程，任务队列",-1),$=a("",2),X=a("",6),Z=a("",35);function ss(is,as,ns,ls,ps,hs){const p=r("font"),e=r("Mermaid");return h(),d("div",null,[y,s("blockquote",null,[c,l(p,{color:"red"},{default:n(()=>[i("如果用的是 main 方法 就不用这么操作了。")]),_:1})]),b,(h(),k(t,null,{default:n(()=>[l(e,{id:"mermaid-537",class:"mermaid my-class",graph:"graph%20LR%20%0AHead%20--%3E%20H1%0AH1%20--%3E%20H2%0AH2%20--%3E%20H3%0AH3%20--%3E%20H4%0AH4%20--%3E%20H5%0AH5%20--%3E%20Tail%0A"})]),fallback:n(()=>[i(" Loading... ")]),_:1})),s("blockquote",null,[F,o,l(p,{color:"red"},{default:n(()=>[i("调用`ctx.writeAndFlush`也能写出数据，但是会从当前位置往前找出栈的处理器")]),_:1}),i("，具体操作可以把h3的"),u,i("换成"),m,i("，想要看有h4打印数据，则需要将h4添加在H3的前边。")]),A,(h(),k(t,null,{default:n(()=>[l(e,{id:"mermaid-713",class:"mermaid my-class",graph:"graph%20LR%0Afq%5B%E5%BA%9F%E5%BC%83%E9%83%A8%E5%88%86%5D%20--%3E%20kd%5B%E5%8F%AF%E8%AF%BB%E9%83%A8%E5%88%86%5D%0Akd%20--%3Ekk%5B%E5%8F%AF%E5%86%99%E9%83%A8%E5%88%86%5D%0Akk--%3Ekr%5B%E5%8F%AF%E6%89%A9%E5%AE%B9%E9%83%A8%E5%88%86%5D%20%0A"})]),fallback:n(()=>[i(" Loading... ")]),_:1})),C,s("blockquote",null,[s("p",null,[s("strong",null,[l(p,{color:"red"},{default:n(()=>[i("切片后不允许往切片后插入新值。")]),_:1})])]),D]),B,s("p",null,[s("strong",null,[l(p,{color:"red"},{default:n(()=>[i("本质是因为TCP是流式协议，消息没有边界，需要自己找边界")]),_:1})])]),v,s("blockquote",null,[f,s("p",null,[s("strong",null,[l(p,{color:"red"},{default:n(()=>[i("需要设置在最前边来解码，按着设定好的字节数来解码")]),_:1})])]),S]),_,s("blockquote",null,[w,q,s("p",null,[i("**"),l(p,{color:"red"},{default:n(()=>[i("HttpServerCodec")]),_:1}),i("**是Http写的编解码器，带"),T,i("的都是既可以编码又可以解码")])]),x,s("blockquote",null,[L,O,l(p,{color:"red"},{default:n(()=>[i("**其中内容长度前边有16个字节，长度字节为4，长度后紧跟着内容所有第三个参数为0，因为自定义了解码器所以不需要除去前边的内容，最后一个参数为0**")]),_:1})]),R,s("blockquote",null,[j,s("p",null,[i("答案是**"),l(p,{color:"red"},{default:n(()=>[i("不可以！")]),_:1}),i("**")])]),N,s("ul",null,[I,s("li",null,[l(p,{color:"red"},{default:n(()=>[i("用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出timeout异常")]),_:1})]),P]),H,(h(),k(t,null,{default:n(()=>[l(e,{id:"mermaid-1407",class:"mermaid my-class",graph:"sequenceDiagram%0A%20%20%20%20participant%20client%0A%20%20%20%20participant%20server%0A%20%20%20%20participant%20sync_queue%0A%20%20%20%20participant%20accept_queue%0A%20%20%20%20server-%3E%3Eserver%3A%20bind()%0A%20%20%0A%20%20%20%20client-%3E%3Eclient%3A%20connect()%0A%20%20%20%20server-%3E%3Eserver%3A%20listen()%0A%20%20%20%20note%20left%20of%20client%3A%20SYNC_SEND%0A%20%20%20%20client-%3E%3Eserver%3A%201.%20SYN%0A%20%20%20%20server-%3E%3Esync_queue%3A%20put%0A%20%20%20%20note%20left%20of%20sync_queue%3A%20SYNC_RCVD%0A%20%20%20%20server-%3E%3Eclient%3A%202.%20SYN%20%2B%20ACK%0A%20%20%20%20note%20left%20of%20client%3A%20ESTABLISHED%0A%20%20%20%20client-%3E%3Eserver%3A%203.%20ACK%0A%20%20%20%20sync_queue-%3E%3Eaccept_queue%3A%20put%0A%20%20%20%20note%20left%20of%20sync_queue%3A%20ESTABLISHED%0A%20%20%20%20%20accept_queue--%3E%3Eserver%3A%20%0A%20%20%20%20server-%3E%3Eserver%3A%20accept()%0A"})]),fallback:n(()=>[i(" Loading... ")]),_:1})),M,s("blockquote",null,[G,l(p,{color:"red"},{default:n(()=>[i("从网络上读取数据的时候，直接内存要比堆内存效率更高。所哟netty默认IO操作是直接内存")]),_:1})]),U,s("blockquote",null,[z,l(p,{color:"red"},{default:n(()=>[i("控制 netty 接受缓冲区的大小")]),_:1}),V]),K,s("blockquote",null,[s("p",null,[i("源码位置 "),J,i("，"),s("strong",null,[l(p,{color:"red"},{default:n(()=>[i("主要用来切换线程，由主线程切换到eventLoop线程")]),_:1})])]),W]),Y,s("blockquote",null,[Q,l(p,{color:"red"},{default:n(()=>[i("NioEventLoop机会处理io事件，也会处理普通任务和定时任务")]),_:1}),$]),X,l(p,{color:"red"},{default:n(()=>[i("为了遍历SelectedKey时提高性能，所以维护了两套selector")]),_:1}),Z])}const ts=E(g,[["render",ss]]);export{ks as __pageData,ts as default};
